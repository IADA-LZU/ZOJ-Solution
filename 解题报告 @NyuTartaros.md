#ZOJ1086 Octal Fraction 解题报告 @NyuTartaros  

本题要求将一个八进制小数（小于1）转为十进制并输出，小数长度不限制，即需要使用高精度计算。  
在不考虑高精度的理论情况下，本题有3种较显然的解法。 
 
我们首先约定表示法：  
0.O1O2O3...Om[8] = 0.D1D2D3...Dm[10]  

**法1** (直接转换)：  
ex: (0.75)[8] = (7*8^(-1) + (5*8^(-2))[10] = (0.93125)[10]  

**法2** (法1的优化算法)：  
见《ACM国际大学生程序设计竞赛题解(2)》  
ex: (0.75)[8] = (7*8^(-1) + (5*8^(-2))[10] = ((5/8+7) /8)[10] = (0.93125)[10]  

**法3**：  
将每一位看做以八的次幂为分母的分数，每一位加起来最终得到的分数直接转化为小数即可。  
例如0.O1O2O3...Om[8]，我们这里要将Om前面的任意Oi都与Om通分，即分子乘以 8^(m-i) 然后累加即可，最终除以 8^(m) 即可。  
当然本算法为了简化代码，也可以设计成类似于法2的迭代算法。即对于O1，乘以8然后加到O2上，再将结果乘以8加到O3上，迭代进行。  
本算法特点是把小数的高精度计算转化为整数计算，简化了编程工作。

**结论**：
上述三法实际时间复杂度均为_**O(n)**_，但相比于法1，另两种方法都简化了编程操作，同时在运算上做出微量的优化。我认为在ACM竞赛中实际编程效率和微小的程序运行时间优化（因为时间点卡得很严格）都非常重要，所以“手上功夫”就显得至关重要。 在这一角度下法1并不可取。  
而法3虽然简化了绝大多数代码和计算，但是最终归结到一个两个极大数字的高精度除法，切除数比被除数大得多，并不好编写。  
综合来看，法2是最优的。  

法2代码见 /1086/SAMPLE_C_0ms_168kB.c  
